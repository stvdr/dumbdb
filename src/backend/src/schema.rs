use std::collections::HashMap;

use crate::parser::parser::{FieldDefinition, FieldDefinitions, FieldType};

#[derive(Clone, Debug, PartialEq, Eq)]
struct FieldInfo {
    typ: i32,
    length: u64,
}

impl FieldInfo {
    pub fn new(typ: i32, length: u64) -> Self {
        Self { typ, length }
    }

    /// Map a `FieldType` provided by the parser to the FieldInfo required by a `Schema`.
    ///
    /// # Arguments
    ///
    /// * `typ` - A FieldType generated by the Parser.
    pub fn from_field_type(typ: &FieldType) -> Self {
        match typ {
            FieldType::Int => Self { typ: 0, length: 0 },
            FieldType::Varchar(len) => Self {
                typ: 1,
                length: *len as u64,
            },
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Schema {
    fields: Vec<String>,
    info: HashMap<String, FieldInfo>,
}

impl Schema {
    pub fn new() -> Self {
        Self {
            fields: vec![],
            info: HashMap::new(),
        }
    }

    /// Converts `FieldDefinitions` provided by the `Parser` into a `Schema`.
    ///
    /// # Arguments
    ///
    /// * `fields` - The `FieldDefinitions` that have been generated by the `Parser`.
    pub fn from_field_defs(fields: &FieldDefinitions) -> Self {
        Self {
            fields: fields.iter().map(|f| f.0.clone()).collect(),
            info: fields
                .iter()
                .map(|f| (f.0.clone(), FieldInfo::from_field_type(&f.1)))
                .collect(),
        }
    }

    // TODO: make schemas immutable?
    /// Add a field to an existing `Schema`.
    pub fn add_field(&mut self, name: &str, typ: i32, length: u64) -> &mut Self {
        assert!(!self.fields.contains(&name.to_string()));
        self.fields.push(name.to_string());
        self.info
            .insert(name.to_string(), FieldInfo::new(typ, length));
        self
    }

    pub fn add_int_field(&mut self, name: &str) -> &mut Self {
        self.add_field(name, 0, 0);
        self
    }

    pub fn add_string_field(&mut self, name: &str, length: u64) {
        self.add_field(name, 1, length);
    }

    // TODO: return a `Result` isntead of calling `expect`.
    /// Adds a field from an existing schema.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the field that must exist in the other schema.
    /// * `sch` - The other schema that contains the field.
    pub fn add_from(&mut self, name: &str, sch: &Schema) {
        let typ = sch
            .get_field_type(&name)
            .expect(&format!("schema has no field named '{}'", name));
        let len = sch
            .get_field_length(&name)
            .expect(&format!("schema has no field named '{}'", name));

        self.add_field(name, typ, len);
    }

    pub fn add_all(&mut self, sch: &Schema) {
        for field_name in sch.fields.iter() {
            self.add_from(field_name, sch);
        }
    }

    pub fn get_field_type(&self, name: &str) -> Option<i32> {
        self.info.get(name).map(|f| f.typ)
    }

    pub fn get_field_length(&self, name: &str) -> Option<u64> {
        self.info.get(name).map(|f| f.length)
    }

    pub fn fields(&self) -> Vec<String> {
        self.fields.clone()
    }

    pub fn has_field(&self, name: &str) -> bool {
        self.fields.contains(&name.to_string())
    }
}

#[macro_export]
macro_rules! make_schema {
    ($( $name:expr => $typ:tt $( ($len:expr) )? ),*) => {{
        use crate::{schema::Schema};
        let mut schema = Schema::new();
        $(
            match stringify!($typ) {
                "i32" => { schema.add_int_field($name); },
                "varchar" => {
                    let mut len = 255;
                    $ ( len = $len; )?
                    schema.add_string_field($name, len);
                },
                _ => panic!("Unsupported field type"),
            }
        )*
        schema
    }};
}
